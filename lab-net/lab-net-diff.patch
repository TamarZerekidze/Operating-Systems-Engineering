diff --git a/kernel/e1000.c b/kernel/e1000.c
index 70a2adf..69efe5f 100644
--- a/kernel/e1000.c
+++ b/kernel/e1000.c
@@ -102,7 +102,29 @@ e1000_transmit(struct mbuf *m)
   // the TX descriptor ring so that the e1000 sends it. Stash
   // a pointer so that it can be freed after sending.
   //
-  
+  acquire(&e1000_lock);
+  uint64 idx = regs[E1000_TDT];
+
+  if (idx > TX_RING_SIZE){
+    release(&e1000_lock);
+    return -1;
+  }
+    
+  if(!(tx_ring[idx].status & E1000_TXD_STAT_DD)) {
+    release(&e1000_lock);
+    return -1;
+  }
+
+  if (tx_mbufs[idx])
+    mbuffree(tx_mbufs[idx]);
+  tx_mbufs[idx] = m;
+  tx_ring[idx].addr = (uint64)(tx_mbufs[idx]->head);
+  tx_ring[idx].length = (uint64)(tx_mbufs[idx]->len);
+  tx_ring[idx].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;
+
+  regs[E1000_TDT] = (idx + 1)%TX_RING_SIZE;
+  release(&e1000_lock);
+
   return 0;
 }
 
@@ -115,6 +137,22 @@ e1000_recv(void)
   // Check for packets that have arrived from the e1000
   // Create and deliver an mbuf for each packet (using net_rx()).
   //
+  while(1){
+    uint64 rdt = regs[E1000_RDT];
+    uint64 idx = (rdt + 1) % RX_RING_SIZE;
+
+    if(!(rx_ring[idx].status & E1000_RXD_STAT_DD))
+      return;
+
+    rx_mbufs[idx]->len = rx_ring[idx].length;
+    net_rx(rx_mbufs[idx]);
+    rx_mbufs[idx] = mbufalloc(0);
+    rx_ring[idx].addr = (uint64) rx_mbufs[idx]->head;
+    rx_ring[idx].status = 0;
+    regs[E1000_RDT] = idx;
+    
+  }
+
 }
 
 void
diff --git a/lab-lock-handin.tar.gz b/lab-lock-handin.tar.gz
new file mode 100644
index 0000000..35d01e9
Binary files /dev/null and b/lab-lock-handin.tar.gz differ
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..d8263ee
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+2
\ No newline at end of file
