diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..f8bc891
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,6 @@
+{
+    "files.associations": {
+        "atomic": "c",
+        "cstring": "c"
+    }
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 212a89d..05595f0 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_alarmtest\
 
 
 
diff --git a/answers-traps.txt b/answers-traps.txt
new file mode 100644
index 0000000..0ece986
--- /dev/null
+++ b/answers-traps.txt
@@ -0,0 +1,6 @@
+1. parameter transfer when calling function uses registers a0-a7 to store arguments, in this case 13 is stored in a2 register.
+2. because of inlining, f and g functions are not directly called in main, f's calculated value is stored into register.
+3. 0x652
+4. 0x38
+5.the output is HE110 World. we would change i into 0x726c6400 (so that it will print rld instead of dlr).
+6.it is a garbage value from register that stores function parameters.
\ No newline at end of file
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..0e83ce7 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -185,5 +185,6 @@ void            virtio_disk_init(void);
 void            virtio_disk_rw(struct buf *, int);
 void            virtio_disk_intr(void);
 
+void            backtrace(void);
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/kernel/printf.c b/kernel/printf.c
index 1a50203..fa40799 100644
--- a/kernel/printf.c
+++ b/kernel/printf.c
@@ -133,3 +133,13 @@ printfinit(void)
   initlock(&pr.lock, "pr");
   pr.locking = 1;
 }
+
+void
+backtrace(void)
+{
+    uint64 fp = r_fp();
+  while(fp < PGROUNDUP(fp)) {
+    printf("%p\n", *(uint64*)(fp-8));
+    fp = *(uint64*)(fp - 16);
+  }
+}
diff --git a/kernel/proc.c b/kernel/proc.c
index 58a8a0b..19e6e59 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -124,7 +124,10 @@ allocproc(void)
 found:
   p->pid = allocpid();
   p->state = USED;
-
+  p->handling = 0;
+  p->alarm_interval = 0;
+  p->alarm_handler = 0;
+  p->ticks = 0;
   // Allocate a trapframe page.
   if((p->trapframe = (struct trapframe *)kalloc()) == 0){
     freeproc(p);
@@ -132,6 +135,12 @@ found:
     return 0;
   }
 
+  if((p->saved_trapframe = (struct trapframe*)kalloc()) == 0){
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
   if(p->pagetable == 0){
@@ -158,6 +167,9 @@ freeproc(struct proc *p)
   if(p->trapframe)
     kfree((void*)p->trapframe);
   p->trapframe = 0;
+  if(p->saved_trapframe)
+    kfree((void*)p->saved_trapframe);
+  p->saved_trapframe = 0; 
   if(p->pagetable)
     proc_freepagetable(p->pagetable, p->sz);
   p->pagetable = 0;
@@ -169,6 +181,10 @@ freeproc(struct proc *p)
   p->killed = 0;
   p->xstate = 0;
   p->state = UNUSED;
+  p->handling = 0;
+  p->alarm_interval = 0;
+  p->alarm_handler = 0;
+  p->ticks = 0;
 }
 
 // Create a user page table for a given process, with no user memory,
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..2849d75 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -91,7 +91,12 @@ struct proc {
   int killed;                  // If non-zero, have been killed
   int xstate;                  // Exit status to be returned to parent's wait
   int pid;                     // Process ID
-
+  int ticks;
+  int alarm_interval;
+  uint64 alarm_handler;  
+  int handling;
+  struct trapframe* saved_trapframe;
+  
   // wait_lock must be held when using this:
   struct proc *parent;         // Parent process
 
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..5ccee95 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -327,6 +327,14 @@ sfence_vma()
   asm volatile("sfence.vma zero, zero");
 }
 
+static inline uint64
+r_fp()
+{
+  uint64 x;
+  asm volatile("mv %0, s0" : "=r" (x) );
+  return x;
+}
+
 typedef uint64 pte_t;
 typedef uint64 *pagetable_t; // 512 PTEs
 
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..96b34b3 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,8 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_sigalarm(void);
+extern uint64 sys_sigreturn(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +128,8 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_sigalarm]   sys_sigalarm,
+[SYS_sigreturn]  sys_sigreturn
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..c09f4bd 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_sigalarm 22
+#define SYS_sigreturn 23
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..3cb2c02 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -51,6 +51,7 @@ sys_sbrk(void)
 uint64
 sys_sleep(void)
 {
+  backtrace();
   int n;
   uint ticks0;
 
@@ -91,3 +92,28 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_sigalarm(void)
+{
+  int ticks;
+  uint64 handler;
+  argint(0, &ticks);
+  argaddr(1, &handler);
+  
+  struct proc *p = myproc();
+  p->alarm_interval = ticks;
+  p->alarm_handler = handler;
+
+  return 0;
+}
+
+uint64
+sys_sigreturn(void)
+{
+  struct proc *p = myproc();
+  memmove(p->trapframe, p->saved_trapframe, sizeof(struct trapframe));
+  p->handling = 0;
+  
+  return p->trapframe->a0;
+}
diff --git a/kernel/trap.c b/kernel/trap.c
index 512c850..12a8824 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -77,8 +77,19 @@ usertrap(void)
     exit(-1);
 
   // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2)
+  if(which_dev == 2){
+    struct proc *p = myproc();
+
+    if (p->alarm_interval && !(p->handling)) {
+      if (++p->ticks == p->alarm_interval) {
+        memmove(p->saved_trapframe, p->trapframe, sizeof(struct trapframe));
+        p->trapframe->epc = (uint64)(p->alarm_handler);
+        p->handling = 1;
+        p->ticks = 0;
+      }
+    }
     yield();
+  }
 
   usertrapret();
 }
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..bf0d87a
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+4
\ No newline at end of file
diff --git a/user/printf.c b/user/printf.c
index 5c5c782..675e9df 100644
--- a/user/printf.c
+++ b/user/printf.c
@@ -111,3 +111,4 @@ printf(const char *fmt, ...)
   va_start(ap, fmt);
   vprintf(1, fmt, ap);
 }
+ 
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 4d398d5..9426153 100644
--- a/user/user.h
+++ b/user/user.h
@@ -22,6 +22,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int sigalarm(int ticks, void (*handler)());
+int sigreturn(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..3c258dc 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,5 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("sigalarm");
+entry("sigreturn");
\ No newline at end of file
