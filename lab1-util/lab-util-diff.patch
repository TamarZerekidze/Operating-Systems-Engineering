diff --git a/Makefile b/Makefile
index 212a89d..626c10f 100644
--- a/Makefile
+++ b/Makefile
@@ -188,6 +188,11 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_sleep\
+	$U/_pingpong\
+	$U/_primes\
+	$U/_find\
+	$U/_xargs\
 
 
 
@@ -257,6 +262,7 @@ endif
 UEXTRA=
 ifeq ($(LAB),util)
 	UEXTRA += user/xargstest.sh
+
 endif
 
 
diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..62f9457
--- /dev/null
+++ b/time.txt
@@ -0,0 +1 @@
+6
\ No newline at end of file
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..ad70ae5
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,68 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+
+void find(char *path, const char *filename)
+{
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if ((fd = open(path, 0)) < 0) {
+    fprintf(2, "find: cannot open %s\n", path);
+    return;
+  }
+
+  if (fstat(fd, &st) < 0) {
+    fprintf(2, "find: cannot fstat %s\n", path);
+    close(fd);
+    return;
+  }
+
+  if (st.type != T_DIR) {
+    fprintf(2, "error\n");
+    exit(1);
+  }
+
+  if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
+    fprintf(2, "find: path too long\n");
+    return;
+  }
+  strcpy(buf, path);
+  p = buf + strlen(buf);
+  *p++ = '/';
+  while (read(fd, &de, sizeof de) == sizeof de) {
+    if (de.inum == 0 || strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0 )
+      continue;
+    memmove(p, de.name, DIRSIZ);
+    p[DIRSIZ] = 0;              
+    if (stat(buf, &st) < 0) {
+      fprintf(2, "find: cannot stat %s\n", buf);
+      continue;
+    }
+
+    if (st.type == T_DIR) {
+      find(buf, filename);
+    } else if (st.type == T_FILE){
+        if(strcmp(de.name, filename) == 0) printf("%s\n", buf);
+      }
+  }
+
+  close(fd);
+}
+
+int main(int argc, char *argv[])
+{
+  if (argc != 3) {
+    fprintf(2, "error\n");
+    exit(1);
+  }
+  char *path = argv[1];
+  char const *filename = argv[2];
+  find(path,filename);
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..e916ef1
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,54 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(){
+    char t = 't';
+    int p1[2], p2[2];
+    pipe(p1);
+    pipe(p2);
+    int pid = fork();
+    if (pid == 0){
+        close(p1[1]);
+        close(p2[0]);
+        char buf;
+        int n = read(p1[0], &buf, 1);
+        if(n != 1){
+            fprintf(2, "couldn't read/n");
+            close(p1[0]);
+            close(p2[1]);
+            exit(1);
+        }
+        fprintf(1, "%d: received ping\n", getpid());
+        close(p1[0]);
+        n = write(p2[1], &buf, 1);
+        if(n != 1){
+            fprintf(2, "couldn't write/n");
+            close(p2[1]);
+            exit(1);
+        }
+        close(p2[1]);
+        exit(0);
+    } else {
+        close(p1[0]);
+        close(p2[1]);
+        int n = write(p1[1], &t, 1);
+        if(n != 1){
+            fprintf(2, "couldn't write/n");
+            close(p1[1]);
+            close(p2[0]);
+            exit(1);
+        }
+        close(p1[1]);
+        char buf;
+        n = read(p2[0], &buf, 1);
+        if(n != 1){
+            fprintf(2, "couldn't read/n");
+            close(p2[0]);
+            exit(1);
+        }
+        fprintf(1, "%d: received pong\n", getpid());
+        close(p2[0]);
+        exit(0);
+    }
+}
\ No newline at end of file
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..583970e
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,80 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+void primes(int parent[2]) {
+    close(parent[1]);
+    int pr;
+    int n = read(parent[0],&pr,4);
+    if(n == 0) {
+        close(parent[0]);
+        exit(0);
+    } else if (n != 4) {
+        fprintf(2, " couldn't read\n");
+        close(parent[0]);
+        wait((int *) 0);
+        exit(1);
+    }
+    fprintf(1, "prime %d\n", pr);
+    int child[2];
+    pipe(child);
+    int pid = fork();
+    if (pid != 0) {
+        close(child[0]);
+        while(1){
+            int k;
+            n = read(parent[0],&k,4);
+            if(n == 0) {
+                close(parent[0]);
+                break;
+            } else if (n != 4) {
+                fprintf(2, " couldn't read\n");
+                close(parent[0]);
+                close(child[1]);
+                wait((int *) 0);
+                exit(1);
+            }
+            if (k % pr) {
+                n = write(child[1], &k, 4); 
+                if (n != 4){
+                    fprintf(2, " couldn't write\n");
+                    close(parent[0]);
+                    close(child[1]);
+                    wait((int *) 0);
+                    exit(1);
+                }
+            }
+        }
+        close(child[1]);
+        wait((int *) 0);
+    } else {
+        close(parent[0]);
+        primes(child);
+    }
+    exit(0);
+}
+
+int main(){
+    int p[2];
+    pipe(p);
+    int pid = fork();
+    if (pid != 0) {
+        close(p[0]);
+        for(int i = 2; i <= 35; i++) {
+            int n = write(p[1], &i, 4);
+            if (n != 4){
+                fprintf(2, " couldn't write\n");
+                close(p[1]);
+                wait((int *) 0);
+                exit(1);
+            }
+        }
+        close(p[1]);
+        wait((int*) 0);
+        exit(0);
+    } else {
+        close(p[1]);
+        primes(p);
+    }
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/sleep.c b/user/sleep.c
new file mode 100644
index 0000000..bc5e5fb
--- /dev/null
+++ b/user/sleep.c
@@ -0,0 +1,13 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[]){
+    if(argc < 2 ){
+        fprintf(2,"error\n");
+        exit(1);
+    }
+    int t = atoi(argv[1]);
+    sleep(t);
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..c4ead19
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,60 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/param.h"
+
+int main(int argc, char const *argv[])
+{
+	if (argc <= 1)
+	{
+		fprintf(2, "error\n");
+		exit(1);
+	}
+
+    char *args[MAXARG];
+    char c;
+    char buf[512];
+
+	char *command = malloc(strlen(argv[1]) + 1);
+	strcpy(command, argv[1]);
+
+	for (int i = 1; i < argc; ++i)
+	{
+		args[i - 1] = malloc(strlen(argv[i]) + 1);
+		strcpy(args[i - 1], argv[i]);
+	}
+
+    for (int i = argc - 1; i < MAXARG ; i++)
+        args[i] = 0;
+    
+    memset(buf, 0, sizeof(buf));
+    int j = 0;
+    while (read(0, &c, 1)) {
+        if (c == '\n') {
+            if (j != 0) {
+                buf[j] = '\0';
+                args[argc - 1] = buf;
+                j = 0;
+                if(fork() == 0){
+			        exec(command, args);
+			        fprintf(2, "error\n");
+			        exit(1);
+		        } else {
+                    wait((int*)0);
+                    }
+            }
+        } else buf[j++] = c;
+    }
+    if (j != 0) {
+        buf[j] = '\0';
+        args[argc - 1] = buf;
+        if(fork() == 0){
+			exec(command, args);
+			fprintf(2, "error\n");
+			exit(1);
+		}else {
+            wait((int*)0);
+            }
+    }
+    exit(0);
+}
\ No newline at end of file
